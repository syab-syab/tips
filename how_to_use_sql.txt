SQL文の使い方
以下を参照 → https://www.youtube.com/watch?v=v-Mb2voyTbc&t=2908s&ab_channel=%E3%81%A0%E3%82%8C%E3%81%A7%E3%82%82%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%2F%E5%B1%B1%E6%B5%A6%E6%B8%85%E9%80%8F
--------------------------------------------------------------------------------
・できること
    ┃
    ┣━ データの保管、取得、更新、削除
    ┃
    ┣━ テーブルの作成、更新、削除
    ┃
    ┣━ アプリ開発時にデータベースを操作できる
    ┃
    ┗━ データを分析してビジネス活動を改善

* SQLを書く上での秘訣
    ┃
    ┣━ 予約語(SELECT, WHERE 等)は大文字
    ┃
    ┣━ 特定の予約語(SELECT, WHERE, ORDER BY 等)の後は改行する
    ┃
    ┗━ SELECTで列名指定、LIMITすると速くなる(SELECT * を実行すると動作が遅くなることがある)

-----------------------------------------------------------------------------
・書き順
SELECT >> DISTINCT >> FROM >> JOIN ON >> WHERE >> GROUP BY >> HAVING >> ORDER BY >> LIMIT

INSERT >> INTO >> VALUES

UPDATE >> SET >> WHERE

DELETE >> FROM >> WHERE

-----------------------------------------------------------------------------
・SELECT FROM

SELECT カラム名(複数指定可 (ex.カラム1,カラム2))
FROM テーブル名;

------------------------------------------------------------------------------
・AS : カラムに別名を付ける

SELECT カラム名
AS '変更後の名前' FROM テーブル名;

------------------------------------------------------------------------------
・* : 全カラムを指定

SELECT *
FROM テーブル名;

-------------------------------------------------------------------------------
・DISTINCT : 重複削除

SELECT DISTINCT(対象のカラム名)
FROM テーブル名;

------------------------------------------------------------------------------
・WHERE : 条件指定

SELECT カラム名
FROM テーブル名
WHERE 条件(ex. width > 5);

※「!=」は「<>」と記述すること
  でもやっぱり「!=」でもいけるかもしれない

-----------------------------------------------------------------------------
・AND : 両方満たす(条件)

SELECT *
FROM テーブル名
WHERE 条件1 AND 条件2(ex. city = 'Tokyo');

-------------------------------------------------------------------------------
・OR : どちらか満たす(条件)

SELECT *
FROM テーブル名
WHERE 条件1 OR 条件2;

-----------------------------------------------------------------------------
・BETWEEN : ～の間(条件)
※WHERE句

SELECT *
FROM テーブル名
WHERE カラム名(ex. height) BETWEEN 下限値(ex. 4) AND 上限値(ex. 6);

※BETWEEN演算子を否定する場合は、カラム名 NOT BETWEEN 下限値 AND 上限値

--------------------------------------------------------------------------------
・IN : まとめて指定(条件)

SELECT *
FROM テーブル名
WHERE カラム名(ex. city) IN ("Tokyo", "Kyoto");

※NOT IN : まとめて否定(条件)

-----------------------------------------------------------------------------------
・LIKE : あいまい検索(条件)
※WHERE句

SELECT *
FROM テーブル名
WHERE カラム名(ex. country) LIKE 比較文字列(ex. 'J%'(Jから始まるものを検索));

※比較文字列に使えるワイルドカード
  「%」 .... 0文字以上の任意の文字列
             ex.) LIKE "%AT%" なら "AT", "ATTIC", "CAT", "BATS" などがマッチする

  「_」 .... 1文字の任意の文字
             ex.) LIKE "AN_" なら "AND" には一致するが、"AN" には一致しない)

※%や_そのものを検索文字列として使用したい場合はESCAPEキーワード「?」を使用する
  ex.) WHERE ENAME LIKE '%?_%' ESCAPE '?'

※否定の場合は カラム名 NOT LIKE 比較文字列 と記述する
  ex.) WHERE ENAME NOT LIKE '%A%'

※アルファベットの場合、大文字と小文字を区別しない？


-------------------------------------------------------------------------------------
・IS NULL : 値がNULLのものを指定(条件)

SELECT *
FROM テーブル名
WHERE カラム名 IS NULL;

※IS NOT NULL : NULLではないものを指定

--------------------------------------------------------------------------------
・LIMIT : 行数上限指定
※取得するデータ量を減らして動作を軽くしたいときに使う

SELECT *
FROM テーブル名
LIMIT 2; 　　　　　　　.... 指定したテーブルから2行目まで取ってくる

------------------------------------------------------------------------------
・ORDER BY : 並び替え
※WHEREの後ろ

SELECT *
FROM テーブル名
ORDER BY カラム名(ex. age); .... 指定したカラム名を元に並び替えて取得する

※デフォルトだと昇順(小さい順)
　文の末尾に DESC と加えることで降順に並び替えることができる

----------------------------------------------------------------------------------
・OFFSET : 
※後でやる
----------------------------------------------------------------------------------
・GROUP BY : 指定したカラムの値を基準にデータをグループ化することができる
※WHEREの後ろ

ex.) SELECT job, AVG(sal)
     FROM emp
     WHERE deptno <> 10
     GROUP BY job;  .... まず、WHERE条件によりレコードが抽出され、
                         GROUP BYで指定したカラムごとにグループ化され、
                         集合関数で計算結果が求められる。

集計関数
  ・COUNT : レコード数
  ・AVG : 平均
  ・MAX : 最大値
  ・MIN : 最小値
  ・SUM : 合計値を求める

    SELECT SUM(カラム)
    FROM テーブル名

※平均値は SUM(カラム名)/COUNT(カラム名) でも算出できる

--------------------------------------------------------------------------------
・HAVING : グループ化したテーブルから条件抽出する
※GROUP BYの後ろ
※WHEREはGROUP BY の前に条件抽出するのに対して、HAVINGは後になる

SELECT	カラム名
FROM	テーブル名
GROUP BY	カラム名
HAVING 条件式

ex.) SELECT job
     FROM emp
     GROUP BY job
     HAVING AVG(sal) >= 2500;

--------------------------------------------------------------------------------
複数表への問い合わせ

  ・条件結合
    SELECT テーブル名A.カラム名, テーブル名A.カラム名, テーブル名B.カラム名...
    FROM テーブル名A, テーブル名B
    WHERE テーブル名A.連結させるカラム名 = テーブル名B.連結させるカラム名;

  ※SELECTには表示したいカラム名を記述する
    同じ名前のカラムがある場合に区別するため「テーブル名.カラム」と記述する
  ※WHERE条件で互いのテーブルのカラムを「=」で連結することで
    それぞれのカラムの値が等しい値を連結させる

  ・エイリアス
    SELECT A.カラム名, B.カラム名
    FROM テーブル名A A, テーブル名B B
    WHERE A.連結させるカラム名 = B.連結させるカラム名;

  ※基本的に条件結合と同じだが、「テーブル名A A」のように
    空白を挟んで別名を定義して記述を簡単にする
    値を変数に格納する感じ

--------------------------------------------------------------------------------
入れ子の問い合わせ

  ・副問い合わせ
  例)
    SELECT *
    FROM テーブルA
    WHERE テーブルA.カラム = (
      SELECT MIN(テーブルB.カラム)
      FROM テーブルB
    );
  .... カッコ内側のSELECT MIN(テーブルB.カラム) FROM テーブルB)で抽出された、
       MIN(テーブルB.カラム)とテーブルA.カラムを比較し、
       等しいレコードを抽出する。
       この場合、内側のSELECT文の後に書かれてある項目(ここではMIN(テーブルB.カラム)）は、
       テーブルA.カラムと比較可能なものである必要がある。

  ・IN記述 : ()に囲まれているものを含むレコードを抽出
    SELECT *
    FROM テーブル
    WHERE カラム IN (10, 30); 
    ... FROMで指定したテーブルからカラムの値が10から30のレコードを取り出す

  ※否定をする場合はNOT INと記述

  ・EXISTS記述
    ※後でやる

--------------------------------------------------------------------------------
テーブル結合(JOIN)

  ・INNER JOIN : 内部結合(二つのテーブルの合わさった部分のみ取得)

    SELECT *
      FROM テーブル名(ex. man) AS 変数(ex. m)
      INNER JOIN 結合したいテーブル名(ex. history) AS 変数(ex. h)
        ON 結合条件(ex. m.id = h.man_id);
    ※余計なものを表示させたくなければSELECTで指定する
      上の例だと SELECT m.name, h.country みたいな
    ※条件に合わないレコードは削除される

  ・OUTER JOIN : 外部結合(合致しないものもどちらかのテーブルのすべてのレコードを取得できる？)

    SELECT m.name, h.country
      FROM テーブル名(ex. man) AS 変数(ex. m)
      LEFT OUTER JOIN 結合したいテーブル名(ex. history) AS 変数(ex. h)
        ON 結合条件(ex. m.id = h.man_id);
    ※条件に合わないデータも表示される

-------------------------------------------------------------------------------------------
CASE式
※詳しくは後で
・分析用の分類単位で集計したいときに、集約関数(SUM)とGROUP BY句と一緒に使う
・条件に応じて集計したいときはCASE式
・SQL初心者から中級者へ

  ・CASE : 条件分岐

    SELECT CASE WHEN 条件 THEN 値
           WHEN 条件 THEN 値
      FROM テーブル名

    例) SELECT 
          CASE WHEN pref_name IN ('京都', '大阪') THEN '関西'
          WHEN pref_name IN ('福岡', '佐賀')　THEN '九州'
          ELSE NULL
          END AS district,
          population
        FROM
          populations;

          ↓実行後↓

      |pref_name|population|
      |京都     |300       |
      |大阪     |900       |
      |福岡     |500       |
      |佐賀     |100       |

                ↓

      |district|population|
      |関西    |300       |
      |関西    |900       |
      |九州    |500       |
      |九州    |100       |

    例) SELECT 
          CASE WHEN pref_name IN ('京都', '大阪') THEN '関西'
          WHEN pref_name IN ('福岡', '佐賀')　THEN '九州'
          ELSE NULL
          END AS district,
          SUM(population)
        FROM
          populations
        GROUP BY
          CASE WHEN pref_name IN ('京都', '大阪') THEN '関西'
          WHEN pref_name IN ('福岡', '佐賀')　THEN '九州'
          ELSE NULL
          END

                    ↓実行後↓

              |pref_name|population|
              |京都     |300       |
              |大阪     |900       |
              |福岡     |500       |
              |佐賀     |100       |

                        ↓

              |district|population|
              |関西    |1200      |
              |九州    |600       |

-----------------------------------------------------------------------------------
・サブクエリ : クエリ(セレクト文?)の中のクエリ
※詳しくは後で

例) itemテーブルの中から平均価格以上の商品を取り出すには

|name         |category|price  |
|iPhone12     |スマホ  |100,000|
|Pixel 5      |スマホ  |80,000 |
|Xperia 5Ⅱ   |スマホ  |90,000 |
|ルンバ980    |掃除機  |50,000 |
|Dyson V10    |掃除機  |40,000 |
|バルミューダC|掃除機  |60,000 |

上のテーブルを↓のようにする

|name         |category|price  |
|iPhone12     |スマホ  |100,000|
|Pixel 5      |スマホ  |80,000 |
|Xperia 5Ⅱ   |スマホ  |90,000 |

↓のように書けば↑の結果が得られる

SELECT *
      FROM items
    WHERE price >= (SELECT AVG(price)
                      FROM items);
    
    上記の文は
    SELECT AVG(price)
    FROM items;
    の後に
    SELECT *
      FROM items
    FROM price >= 70000;
    を実行したのと同じ

例2) カテゴリーごとに平均価格以上の商品を出すには(相関サブクエリ)


SELECT *
  FROM items AS i1
WHERE price >= (SELECT AVG(price)
                    FROM items AS i2
                  WHERE i1.category = i2.category
                  GROUP BY category);

上の文は

|name         |category|price  |
|iPhone12     |スマホ  |100,000|
|Pixel 5      |スマホ  |80,000 |
|Xperia 5Ⅱ   |スマホ  |90,000 |
|ルンバ980    |掃除機  |50,000 |
|Dyson V10    |掃除機  |40,000 |
|バルミューダC|掃除機  |60,000 |

↑のテーブルに対してすべての行に

SELECT * FROM items WHERE 100000 >= 90000;
SELECT * FROM items WHERE 80000 >= 90000;
SELECT * FROM items WHERE 90000 >= 90000;
SELECT * FROM items WHERE 50000 >= 50000;
SELECT * FROM items WHERE 40000 >= 50000;
SELECT * FROM items WHERE 60000 >= 50000;

という感じで各カテゴリの平均よりも価格が大きいかを比較している

結果は以下のようになる

|name         |category|price  |
|iPhone12     |スマホ  |100,000|
|Xperia 5Ⅱ   |スマホ  |90,000 |
|ルンバ980    |掃除機  |50,000 |
|バルミューダC|掃除機  |60,000 |

ただし

SELECT *
      FROM items
    WHERE price >= (SELECT AVG(price)
                      FROM items
                    GROUP BY category);

と書くと
SELECT *
  FROM items
WHERE price >= (90000, 50000);
となり、エラーとなってしまう

・サブクエリを使う上での注意
    ┃
    ┣━ 重くて複雑なので、使わずに済むなら使わない
    ┃
    ┗━ 二段階以上の集計を行う場合は使わざるを得ない

------------------------------------------------------------------------------------
・INSERT : テーブルに新しいレコード(行)を追加する

INSERT INTO テーブル名(カラム名, カラム名....)
VALUES (値, 値...);

※テーブルの全カラムに値を追加する場合は、テーブル名の後ろのカラム名を省略できる
  INSERT INTO テーブル名
  VALUES (値, 値);

※別のテーブルから選択したレコードを追加するには、INTOの部分をSELECT文に変更
  INSERT INTO 追加するテーブル名
  SELECT カラム名(全てのカラムなら「*」)
  FROM データを持ってくるテーブル名
  WHERE 条件

------------------------------------------------------------------------------------
UPDATE : テーブルに存在するレコードを更新する

UPDATE テーブル名
SET カラム名 = 値, カラム名 = 値...
WHERE 条件;

※WHERE条件を記載しない場合は、すべてのレコードが更新されてしまう

※計算式を使ったレコードの更新
  ex.)UPDATE employee
      SET sal = sal * 1.5
      WHERE id = 11;   .... idが11のレコードのsalカラムの値を1.5倍する

------------------------------------------------------------------------------
DELETE : レコードを削除する

DELETE FROM テーブル名
WHERE 条件

※WHEREに条件を指定しないと、全てのレコードが削除されてしまう

----------------------------------------------------------------------------------
CREATE TABLE : テーブルの作成

CREATE TABLE テーブル名 (
  カラム名 データ型 [オプション(無くてもOK)],
  カラム名 データ型 [オプション(無くてもOK)],
  カラム名 データ型 [オプション(無くてもOK)],
  .....
  カラム名 データ型 [オプション(無くてもOK)],
);

※オプションには
  「NULL, NOT NULL, PRIMARY KEY, DEFAULT, UNIQUE, CHECK, AUTOINCREMENT, FOREIGN KEY()」
※「DEFAULT」 はデフォルト値の指定
※「NOT NULL」 はNULLの格納を許可しない
※「PRIMARY KEY」 は主キーの指定
※「UNIQUE」 はユニーク制約(カラムの値が重複しないようにする)
※「CHECK」 はCHECK制約
  (データ追加時に値が指定した条件を満たしているかどうかのチェック)
※「AUTOINCREMENT」 はINTEGER型のカラムの場合、レコードが追加される度に
  格納されている最大の数値に1を追加した数値が自動的に格納される
  (対応していないデータベースもある)
※「FOREIGN KEY」 は参照整合性(テーブル間の整合性)の崩壊を防ぐために
  子テーブル側で指定する  ※詳しくは後で

※既存のテーブルと同じ名前のテーブルを作成しようとするとエラーが発生する
  「IF NOT EXISTS」をテーブル名の前に入れるとエラーが発生しない
  (ただし、テーブルも作成されない)

--------------------------------------------------------------------------------
ALTER TABLE : テーブル構造の変更

・カラムの追加
  ALTER TABLE テーブル名
  ADD カラム名 データ型 [オプション];

  ※オプションはテーブル作成の場合のそれと同じ、多分
  ※デフォルト値を追加すると、既存のレコードにも反映されるっぽい

・カラム名の変更
  ALTER TABLE テーブル名
  CHANGE COLUMN 旧カラム名 新カラム名 データ型 [オプション];

・カラムの削除
  ALTER TABLE テーブル名
  DROP カラム名;

・テーブル名の変更
  ALTER TABLE テーブル名
  RENAME TO 新テーブル名;

-----------------------------------------------------------------------------------
DROP TABLE : テーブルの削除

  DROP TABLE テーブル名;

  ※テーブル作成と同様に、IF EXISTS」をテーブル名の前に入れるとエラーが発生しない

-------------------------------------------------------------------------------------------
